#!/usr/bin/env python3
# Copyright (c) nexB Inc.
# Copyright (c) 2016-2019 Christoph Reiter
# SPDX-License-Identifier: MIT
#
# Based on MSYS2 web application code.
# download_url: https://raw.githubusercontent.com/msys2/msys2-web/628ec96975ab84b4e13567c8d4bdc25ad1a8f937/main.py
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
"""
Utility to keep Windows prebuilt ScanCode toolkit plugins up to date.

This library fetches an msys2 binary package archive and then fetches all its
recursive binary and source packages dependencies. Archives are then extracted.
Finally a configured subset of the files (e.g. dlls, licenses, etc) are installed
in a target directory of a plugin.

Note that the file formats are the same as for ArchLinux.

A Windows packages repository from MSYS2 is essentially an Archlinux AUR/pacman
repository.

Theory of operations:
We start by collecting package index pages and get the URLs to all packages
Then we process the root package found in the index:
 - fetch, extract, install and same for its source
 - repeat this for each dependency

- we only deal with 64 bits packages and ignore 32 bits
- there are msys packages (built with Cygwin) and mingw packages (standalone)
- for each of these we have sources and binaries
- for each of these sources and binaries, we have an index in a repo at http://repo.msys2.org/:
  - either as an HTML directory listing of archives
  - or as .db file which is a tar.gz tarball that contains one directory per
    latest version of a package with a desc file
- each archive contains the payload of installable files and some metadata:
    - for binaries: .PKGINFO: key=value pairs, same as archlinux
    See     # https://wiki.archlinux.org/index.php/User:Apg#String_List_Fields
    - for sources: .SRCINFO: key=value pairs, same as archlinux
    See https://wiki.archlinux.org/index.php/.SRCINFO
    -  Both are generated by makepkg
    - other such as (.BUILDINFO, .MTREE) of no interest for now.

- each archive also has a <archive name>.sig file with a PGP signature for
  verification.

Of note: a tarball can be compressed with gzip, xz, or zstd.
"""

from collections import defaultdict
from distutils.dir_util import copy_tree
import fnmatch
import functools
import glob
from itertools import zip_longest
import os
import re
import shutil
import sys

import attr


#
REQUEST_TIMEOUT = 60

TRACE = False
TRACE_DEEP = False
TRACE_FETCH = False
TRACE_DEP = True
TRACE_INSTALL = False

CACHE_DIR = "src-msys2"
BIN_CACHE_DIR = os.path.join(CACHE_DIR, "bin")
SRC_CACHE_DIR = os.path.join(CACHE_DIR, "src")

################################################################################
# Package repositories
################################################################################


@attr.attributes
class Repository:
    """
    A repository is a collection of package binaries and sources.
    """

    binaries_url = attr.ib(
        type=str,
        metadata=dict(
            help="URL to HTML listing of package binaries such as http://repo.msys2.org/mingw/x86_64"
        ),
    )

    sources_url = attr.ib(
        type=str,
        metadata=dict(
            help="URL to HTML listing of package sources http://repo.msys2.org/mingw/sources"
        ),
    )

    binaries_by_name = attr.ib(
        type=dict,
        default=attr.Factory(lambda: defaultdict(list)),
        metadata=dict(
            help="Mapping of {package name: [list of BinaryPackage versions]} available in this repo"
        ),
    )
    sources_by_name = attr.ib(
        type=dict,
        default=attr.Factory(lambda: defaultdict(list)),
        metadata=dict(
            help="Mapping of {package name: [list of SourcePackage versions]} available in this repo"
        ),
    )

    def populate_package_from_index_urls(self):
        """
        Populate BinaryPackage and SourcePackage in this repo.
        Caches the fetched indexes for the duration of a session.
        """
        print(f"Loading Repo from HTML indexes at: {self.binaries_url} and: {self.sources_url}")

        def populate_index(index_url, package_cls):
            by_name = defaultdict(list)
            download_urls = find_download_urls(index_url)
            for download_url, _file_name in download_urls:
                pck = package_cls.from_download_url(download_url)
                by_name[pck.name].append(pck)
            for _name, versions in by_name.items():
                BasePackage.sort(versions)
            return by_name

        self.sources_by_name = populate_index(index_url=self.sources_url, package_cls=SourcePackage)
        self.binaries_by_name = populate_index(
            index_url=self.binaries_url, package_cls=BinaryPackage
        )

    @classmethod
    def update_packages(self, existing_packages, new_packages):
        """
        Update an existing_packages index mapping of {name: [packages]} with
        a new_packages similar mapping:
        - new package versions are added
        - existing package versions empty attributes are updated with new data
        """
        # TODO!
        # this is meant to be used when combining a remote index with a local
        # cache

    def populate_package_from_directory(self):
        """
        Populate BinaryPackage and SourcePackage in this repo.
        Caches the fetched indexes for the duration of a session.
        """
        print(f"Loading Repo from archive directories at: {CACHE_DIR}")

        # TODO!
        # collect archive names and build skinny packages
        # merge in main indexes

    def get_binary_package(self, name, version=None):
        """
        Return the binary Package with `name` and `version` or None if not
        found. Return the latest version if `version` is None.
        """
        packages = self.get_packages(self.binaries_by_name, name)
        return self.get_package_version(packages, version)

    def get_source_package(self, name, version=None):
        """
        Return the source Package with name and version or None if not found.
        Return the latest version if `version` is None.
        """
        packages = self.get_packages(self.sources_by_name, name)
        return self.get_package_version(packages, version)

    @classmethod
    def get_packages(cls, packages_by_name, name):
        """
        Return the list of with name or None if not found.
        """
        return packages_by_name[name] or packages_by_name.get(name + "-git") or None

    @classmethod
    def get_package_version(cls, packages, version=None):
        """
        Return the Package with name and version from packages or None if not
        found. Return the latest version if `version` is None.
        """
        if not packages:
            return
        if len(packages) == 1:
            return packages[0]
        if not version:
            return packages[-1]
        for p in packages:
            if p.version == version:
                return p


EXTENSIONS = (
    ".tar.gz",
    ".tar.bz2",
    ".tar.xz",
    ".tar.zst",
    ".zip",
)
IGNORED_EXTENSIONS = (
    ".db.tar.gz",
    ".files.tar.gz",
    ".sig",
)


def find_download_urls(repo_url):
    """
    Return a list of download URL for HREF  found in the HTML page index at
    `repo_url`.
    """

    _, _, index_file_name = repo_url.partition("//")
    index_file_name = index_file_name.strip("/").replace("/", "-") + ".html"

    index_loc = shared_utils.fetch_file(
        url=repo_url,
        dir_location=CACHE_DIR,
        file_name=index_file_name,
        force=False,
    )

    with open(index_loc) as fi:
        text = fi.read()

    hrefs = find_hrefs(text)
    return [(f"{repo_url}/{href}", href) for href in hrefs]


def find_hrefs(text):
    """
    Return a list of HREF links found in the HTML page `text`.

    For example::
    >>> text = '''
    ... <tr><td valign="top"><img src="/icons/unknown.gif" alt="[   ]"></td><td><a href="mingw-w64-x86_64-libao-1.2.2-1-any.pkg.tar.xz.sig">mingw-w64-x86_64-libao-1.2.2-1-any.pkg.tar.xz.sig</a></td><td align="right">2017-12-21 06:36  </td><td align="right"> 96 </td><td>&nbsp;</td></tr>
    ... <tr><td valign="top"><img src="/icons/unknown.gif" alt="[   ]"></td><td><a href="mingw-w64-x86_64-libarchive-3.4.1-1-any.pkg.tar.xz">mingw-w64-x86_64-libarchive-3.4.1-1-any.pkg.tar.xz</a></td><td align="right">2019-12-31 12:16  </td><td align="right">676K</td><td>&nbsp;</td></tr>
    ... <tr><td valign="top"><img src="/icons/unknown.gif" alt="[   ]"></td><td><a href="mingw-w64-x86_64-libarchive-3.4.1-1-any.pkg.tar.xz.sig">mingw-w64-x86_64-libarchive-3.4.1-1-any.pkg.tar.xz.sig</a></td><td align="right">2019-12-31 12:22  </td><td align="right">119 </td><td>&nbsp;</td></tr>
    ... <tr><td valign="top"><img src="/icons/unknown.gif" alt="[   ]"></td><td><a href="mingw-w64-x86_64-libarchive-3.4.2-1-any.pkg.tar.xz">mingw-w64-x86_64-libarchive-3.4.2-1-any.pkg.tar.xz</a></td><td align="right">2020-02-18 21:03  </td><td align="right">677K</td><td>&nbsp;</td></tr>
    ... <tr><td valign="top"><img src="/icons/unknown.gif" alt="[   ]"></td><td><a href="mingw-w64-x86_64-libarchive-3.4.2-1-any.pkg.tar.xz.sig">mingw-w64-x86_64-libarchive-3.4.2-1-any.pkg.tar.xz.sig</a></td><td align="right">2020-02-18 21:28  </td><td align="right">119 </td><td>&nbsp;</td></tr>
    ... <tr><td valign="top"><img src="/icons/unknown.gif" alt="[   ]"></td><td><a href="mingw-w64-x86_64-libarchive-3.4.2-2-any.pkg.tar.xz">mingw-w64-x86_64-libarchive-3.4.2-2-any.pkg.tar.xz</a></td><td align="right">2020-03-11 07:55  </td><td align="right">677K</td><td>&nbsp;</td></tr>
    ... <tr><td valign="top"><img src="/icons/unknown.gif" alt="[   ]"></td><td><a href="mingw-w64-x86_64-libarchive-3.4.2-2-any.pkg.tar.xz.sig">mingw-w64-x86_64-libarchive-3.4.2-2-any.pkg.tar.xz.sig</a></td><td align="right">2020-03-11 07:56  </td><td align="right">119 </td><td>&nbsp;</td></tr>
    ... <tr><td valign="top"><img src="/icons/unknown.gif" alt="[   ]"></td><td><a href="mingw-w64-x86_64-libarchive-3.4.2-3-any.pkg.tar.zst">mingw-w64-x86_64-libarchive-3.4.2-3-any.pkg.tar.zst</a></td><td align="right">2020-05-06 08:56  </td><td align="right">731K</td><td>&nbsp;</td></tr>
    ... <tr><td valign="top"><img src="/icons/unknown.gif" alt="[   ]"></td><td><a href="mingw-w64-x86_64-libarchive-3.4.2-3-any.pkg.tar.zst.sig">mingw-w64-x86_64-libarchive-3.4.2-3-any.pkg.tar.zst.sig</a></td><td align="right">2020-05-06 08:56  </td><td align="right">119 </td><td>&nbsp;</td></tr>
    ... <tr><td valign="top"><img src="/icons/unknown.gif" alt="[   ]"></td><td><a href="mingw-w64-x86_64-libarchive-3.5.1-1-any.pkg.tar.zst">mingw-w64-x86_64-libarchive-3.5.1-1-any.pkg.tar.zst</a></td><td align="right">2020-05-25 10:42  </td><td align="right">743K</td><td>&nbsp;</td></tr>
    ... <tr><td valign="top"><img src="/icons/unknown.gif" alt="[   ]"></td><td><a href="mingw-w64-x86_64-libarchive-3.5.1-1-any.pkg.tar.zst.sig">mingw-w64-x86_64-libarchive-3.5.1-1-any.pkg.tar.zst.sig</a></td><td align="right">2020-05-25 10:42  </td><td align="right">119 </td><td>&nbsp;</td></tr>
    ... <tr><td valign="top"><img src="/icons/unknown.gif" alt="[   ]"></td><td><a href="mingw-w64-x86_64-libarchive-3.5.0-1-any.pkg.tar.zst">mingw-w64-x86_64-libarchive-3.5.0-1-any.pkg.tar.zst</a></td><td align="right">2020-12-06 13:52  </td><td align="right">732K</td><td>&nbsp;</td></tr>
    ... <tr><td valign="top"><img src="/icons/unknown.gif" alt="[   ]"></td><td><a href="mingw-w64-x86_64-libarchive-3.5.0-1-any.pkg.tar.zst.sig">mingw-w64-x86_64-libarchive-3.5.0-1-any.pkg.tar.zst.sig</a></td><td align="right">2020-12-06 13:57  </td><td align="right">438 </td><td>&nbsp;</td></tr>
    ... <tr><td valign="top"><img src="/icons/unknown.gif" alt="[   ]"></td><td><a href="mingw-w64-x86_64-libart_lgpl-2.3.21-2-any.pkg.tar.xz">mingw-w64-x86_64-libart_lgpl-2.3.21-2-any.pkg.tar.xz</a></td><td align="right">2018-01-17 16:34  </td><td align="right">112K</td><td>&nbsp;</td></tr>
    ... <tr><td valign="top"><img src="/icons/unknown.gif" alt="[   ]"></td><td><a href="mingw-w64-x86_64-libart_lgpl-2.3.21-2-any.pkg.tar.xz.sig">mingw-w64-x86_64-libart_lgpl-2.3.21-2-any.pkg.tar.xz.sig</a></td><td align="right">2018-01-17 16:34  </td><td align="right"> 96 </td><td>&nbsp;</td></tr>
    ... '''
    >>> for href in find_hrefs(text):
    ...     print(href)
    mingw-w64-x86_64-libarchive-3.4.1-1-any.pkg.tar.xz
    mingw-w64-x86_64-libarchive-3.4.2-1-any.pkg.tar.xz
    mingw-w64-x86_64-libarchive-3.4.2-2-any.pkg.tar.xz
    mingw-w64-x86_64-libarchive-3.4.2-3-any.pkg.tar.zst
    mingw-w64-x86_64-libarchive-3.5.1-1-any.pkg.tar.zst
    mingw-w64-x86_64-libarchive-3.5.0-1-any.pkg.tar.zst
    mingw-w64-x86_64-libart_lgpl-2.3.21-2-any.pkg.tar.xz
    """
    get_hrefs = re.compile('href="([^"]+)"').findall
    hrefs = get_hrefs(text)
    hrefs = [l for l in hrefs if l.endswith(EXTENSIONS) and not l.endswith(IGNORED_EXTENSIONS)]
    return hrefs


REPOSITORIES = {
    "mingw64": Repository(
        # vcs_url='https://github.com/msys2/MINGW-packages',
        binaries_url="http://repo.msys2.org/mingw/x86_64",
        sources_url="http://repo.msys2.org/mingw/sources",
    ),
    "msys64": Repository(
        # vcs_url='https://github.com/msys2/MSYS2-packages',
        binaries_url="http://repo.msys2.org/msys/x86_64",
        sources_url="http://repo.msys2.org/msys/sources",
    ),
}

################################################################################
# Packages and archives
################################################################################

SOURCE_TYPE = ".src."
BINARY_TYPE = ".pkg."


@attr.attributes(auto_attribs=True)
class PackageName:
    """
    All the parts of a package name extracted from a source or binary package filename.
    """

    prefix: str
    name: str
    vcs: str
    epoch: str
    version: str
    release: str
    arch: str
    ptype: str
    extension: str

    @property
    def real_name(self):
        return f"{self.name}-{self.vcs}" if self.vcs else self.name

    @property
    def full_name(self):
        """
        Return the full name of a package.
        For example::

        >>> fn = 'mingw-w64-x86_64-libwinpthread-git-8.0.0.5906.c9a21571-1-any.pkg.tar.zst'
        >>> pn = PackageName.from_file_name(fn)
        >>> pn.full_name
        'mingw-w64-x86_64-libwinpthread-git'
        """
        return f"{self.prefix}{self.real_name}"

    @property
    def full_version(self):
        version = self.version
        if self.epoch:
            version = f"{self.epoch}~{version}"
        return f"{version}-{self.release}"

    @classmethod
    def parse_version(cls, version):
        """
        Parse a version string in a string tuple if (epoch, version, release).

        For example::
        >>> PackageName.parse_version('1.0.8-1')
        ('', '1.0.8', '1')
        >>> PackageName.parse_version('1.0.8')
        ('', '1.0.8', '')
        >>> PackageName.parse_version('2~1.0.8')
        ('2', '1.0.8', '')
        >>> PackageName.parse_version('4~1.0.8foo-2')
        ('4', '1.0.8foo', '2')
        """
        epoch, _, vr = version.rpartition("~")
        version, _, release = vr.partition("-")
        return epoch, version, release

    @property
    def file_name(self):
        """
        Return a file_name reconstructed from parts.

        For example::

        >>> names = '''mingw-w64-x86_64-bzip2-1.0.8-1-any.pkg.tar.xz
        ... mingw-w64-x86_64-ca-certificates-20200601-1-any.pkg.tar.zst
        ... mingw-w64-x86_64-expat-2.2.9-1-any.pkg.tar.xz
        ... mingw-w64-x86_64-file-5.39-1-any.pkg.tar.zst
        ... mingw-w64-x86_64-gcc-libs-10.2.0-3-any.pkg.tar.zst
        ... mingw-w64-x86_64-gettext-0.19.8.1-9-any.pkg.tar.zst
        ... mingw-w64-x86_64-gmp-6.2.0-1-any.pkg.tar.xz
        ... mingw-w64-x86_64-libarchive-3.5.1-1-any.pkg.tar.zst
        ... mingw-w64-x86_64-libffi-3.3-1-any.pkg.tar.xz
        ... mingw-w64-x86_64-libiconv-1.16-1-any.pkg.tar.xz
        ... mingw-w64-x86_64-libsystre-1.0.1-4-any.pkg.tar.xz
        ... mingw-w64-x86_64-libtasn1-4.16.0-1-any.pkg.tar.xz
        ... mingw-w64-x86_64-libtre-git-r128.6fb7206-2-any.pkg.tar.xz
        ... mingw-w64-x86_64-libwinpthread-git-8.0.0.5906.c9a21571-1-any.pkg.tar.zst
        ... mingw-w64-x86_64-lz4-1.9.2-1-any.pkg.tar.xz
        ... mingw-w64-x86_64-mpc-1.2.0-1-any.pkg.tar.zst
        ... mingw-w64-x86_64-mpfr-4.1.0-2-any.pkg.tar.zst
        ... mingw-w64-x86_64-nettle-3.6-1-any.pkg.tar.zst
        ... mingw-w64-x86_64-openssl-1.1.1.g-1-any.pkg.tar.xz
        ... mingw-w64-x86_64-p11-kit-0.23.20-2-any.pkg.tar.xz
        ... mingw-w64-bzip2-1.0.8-1.src.tar.gz
        ... mingw-w64-ca-certificates-20200601-1.src.tar.gz
        ... mingw-w64-expat-2.2.9-1.src.tar.gz
        ... mingw-w64-file-5.39-1.src.tar.gz
        ... mingw-w64-gcc-10.2.0-3.src.tar.gz
        ... mingw-w64-gettext-0.19.8.1-9.src.tar.gz
        ... mingw-w64-gmp-6.2.0-1.src.tar.gz
        ... mingw-w64-libarchive-3.5.1-1.src.tar.gz
        ... mingw-w64-libffi-3.3-1.src.tar.gz
        ... mingw-w64-libiconv-1.16-1.src.tar.gz
        ... mingw-w64-libsystre-1.0.1-4.src.tar.gz
        ... mingw-w64-libtasn1-4.16.0-1.src.tar.gz
        ... mingw-w64-libtre-git-r128.6fb7206-2.src.tar.gz
        ... mingw-w64-lz4-1.9.2-1.src.tar.gz
        ... mingw-w64-mpc-1.2.0-1.src.tar.gz
        ... mingw-w64-mpfr-4.1.0-2.src.tar.gz
        ... mingw-w64-nettle-3.6-1.src.tar.gz
        ... mingw-w64-openssl-1.1.1.g-1.src.tar.gz
        ... mingw-w64-p11-kit-0.23.20-2.src.tar.gz
        ... mingw-w64-winpthreads-git-8.0.0.5906.c9a21571-1.src.tar.gz
        ... mingw-w64-xz-5.2.5-1.src.tar.gz
        ... mingw-w64-zlib-1.2.11-7.src.tar.gz
        ... mingw-w64-zstd-1.4.5-1.src.tar.gz
        ... mingw-w64-x86_64-xz-5.2.5-1-any.pkg.tar.xz
        ... mingw-w64-x86_64-zlib-1.2.11-7-any.pkg.tar.xz
        ... mingw-w64-x86_64-zstd-1.4.5-1-any.pkg.tar.zst'''.split()

        >>> for fn in names:
        ...     pfn = PackageName.from_file_name(fn)
        ...     assert fn == pfn.file_name, (pfn, pfn.file_name)
        """

        arch = f"-{self.arch}" if self.arch else ""
        return f"{self.full_name}-{self.full_version}{arch}{self.ptype}{self.extension}"

    @classmethod
    def from_file_name(cls, file_name):
        """
        Return a (prefix, name, epoch, vcs, version, release, arch, ptype, extension) tuple
        parsed from a `file_name`.

        For example::

        >>> PackageName.from_file_name('mingw-w64-x86_64-docbook-xml-1~4.5-1-any.pkg.tar.xz')
        PackageName(prefix='mingw-w64-x86_64-', name='docbook-xml', vcs='', epoch='1', version='4.5', release='1', arch='any', ptype='.pkg.', extension='tar.xz')
        >>> PackageName.from_file_name('parallel-20191022-1-any.pkg.tar.xz')
        PackageName(prefix='', name='parallel', vcs='', epoch='', version='20191022', release='1', arch='any', ptype='.pkg.', extension='tar.xz')
        >>> PackageName.from_file_name('mingw-w64-docbook-xml-1~4.5-1.src.tar.gz')
        PackageName(prefix='mingw-w64-', name='docbook-xml', vcs='', epoch='1', version='4.5', release='1', arch='', ptype='.src.', extension='tar.gz')
        >>> PackageName.from_file_name('base-2020.05-2-any.pkg.tar.zst')
        PackageName(prefix='', name='base', vcs='', epoch='', version='2020.05', release='2', arch='any', ptype='.pkg.', extension='tar.zst')
        >>> PackageName.from_file_name('msys2-launcher-git-0.3.32.56c2ba7-2.src.tar.gz')
        PackageName(prefix='', name='msys2-launcher', vcs='git', epoch='', version='0.3.32.56c2ba7', release='2', arch='', ptype='.src.', extension='tar.gz')
        >>> PackageName.from_file_name('mingw-w64-x86_64-libtre-git-r128.6fb7206-2-any.pkg.tar.xz')
        PackageName(prefix='mingw-w64-x86_64-', name='libtre', vcs='git', epoch='', version='r128.6fb7206', release='2', arch='any', ptype='.pkg.', extension='tar.xz')
        >>> PackageName.from_file_name('mingw-w64-x86_64-libwinpthread-git-8.0.0.5906.c9a21571-1-any.pkg.tar.zst')
        PackageName(prefix='mingw-w64-x86_64-', name='libwinpthread', vcs='git', epoch='', version='8.0.0.5906.c9a21571', release='1', arch='any', ptype='.pkg.', extension='tar.zst')
        >>> PackageName.from_file_name('mingw-w64-x86_64-firebird2-git-2.5.9.27149.9f6840e90c-1-any.pkg.tar.xz')
        PackageName(prefix='mingw-w64-x86_64-', name='firebird2', vcs='git', epoch='', version='2.5.9.27149.9f6840e90c', release='1', arch='any', ptype='.pkg.', extension='tar.xz')
        """
        if not any(pt in file_name for pt in (SOURCE_TYPE, BINARY_TYPE)):
            raise Exception(f"Unknown file_name format: {file_name}")

        PTYPE = SOURCE_TYPE if SOURCE_TYPE in file_name else BINARY_TYPE

        if file_name.startswith("mingw-w64-x86_64-"):
            _, prefix, file_name = file_name.partition("mingw-w64-x86_64-")

        elif file_name.startswith("mingw-w64-"):
            _, prefix, file_name = file_name.partition("mingw-w64-")

        else:
            prefix = ""

        nevra, ptype, extension = file_name.partition(PTYPE)
        if ptype == BINARY_TYPE:
            nevr, _, arch = nevra.rpartition("-")
        else:
            # no arch for sources
            arch = ""
            nevr = nevra

        if "~" in nevr:
            ne, _, vr = nevr.partition("~")
            name, _, epoch = ne.rpartition("-")
            version, _, release = vr.rpartition("-")
        else:
            # no epoch
            epoch = ""
            nv, _, release = nevr.rpartition("-")
            name, _, version = nv.rpartition("-")

        if name.endswith("-git"):
            name, _, vcs = name.rpartition("-")
        else:
            vcs = ""

        return cls(
            prefix=prefix,
            name=name,
            vcs=vcs,
            epoch=epoch,
            version=version,
            release=release,
            arch=arch,
            ptype=ptype,
            extension=extension,
        )


def get_full_version(package_data):
    """
    Given a mapping of package_data that contains a version and may an epoch and
    release, return a complete version.

    For example::
    >>> get_full_version(dict(version='1.2.3'))
    '1.2.3'
    >>> get_full_version(dict(version='1.2.3', epoch='2'))
    '2~1.2.3'
    >>> get_full_version(dict(version='1.2.3', epoch='2', release='23'))
    '2~1.2.3-23'
    """
    version = package_data["version"]

    release = package_data.get("release", "")
    if release:
        release = f"-{release}"

    epoch = package_data.get("epoch", "")
    if epoch:
        epoch = f"{epoch}~"

    version = f"{epoch}{version}{release}"
    return version


def filter_unknown_attributes(cls, package_data):
    """
    Given a  mapping of package_data, return a new mapping of package_data that
    contains only known `cls` attr class attributes.
    """
    known_fields = attr.fields_dict(cls)
    return {key: value for key, value in package_data.items() if key in known_fields}


@attr.attributes(kw_only=True)
class BasePackage:
    name = attr.ib(
        type=str,
        metadata=dict(help="Package name."),
    )

    version = attr.ib(
        type=str,
        metadata=dict(help="Package version."),
    )

    download_url = attr.ib(
        type=str,
        metadata=dict(help="Download URL"),
    )

    arch = attr.ib(
        default="any",
        type=str,
        metadata=dict(
            help='Package architecture. Mostly unused in mingw e.g. "any". Used for msys.'
        ),
    )

    desc = attr.ib(type=str, default=None, metadata=dict(help="description"))
    url = attr.ib(type=str, default=None, metadata=dict(help="home url"))
    licenses = attr.ib(type=list, default=attr.Factory(list), metadata=dict(help="licenses"))

    @property
    def file_name(self):
        return shared_utils.file_name_from_url(self.download_url)

    @property
    def real_name(self):
        pn = PackageName.from_file_name(self.file_name)
        return pn.real_name

    def to_about(self):
        """
        Return an ABOUT data mapping
        """
        return dict(
            about_resource=self.file_name,
            type="msys2",
            name=self.name,
            version=self.version,
            download_url=self.download_url,
            description=self.desc,
            homepage_url=self.url,
            declared_license=self.licenses,
        )

    @classmethod
    def sort(cls, packages):
        """
        Sort a list of `packages` in place by version.
        All package are assumed to have the same name.
        """
        if not packages or len(packages) == 1:
            return packages

        packages.sort(key=lambda p: version_sort_key(p.version))

    def update_with_package(self, package):
        """
        Update package with a `package` object.
        """
        for field in attr.fields_dict(self.__class__):
            value = getattr(self, field)
            new_value = getattr(package, field)
            if new_value and not value:
                setattr(self, field, new_value)

    def update_with_package_data(self, package_data):
        """
        Update package with a `package_data` mapping.
        """
        new_package = self.from_package_data(package_data)
        self.update_with_package(new_package)

    def update_with_info(self, pkginfo_or_srcinfo_location):
        """
        Update self with data found in the .PKGINFO or .SRCINFO file at
        `pkginfo_or_srcinfo_location`
        """
        with open(pkginfo_or_srcinfo_location) as fi:
            text = fi.read()
        pkgdata = parse_pkginfo(text)
        self.update_with_package_data(package_data=pkgdata)

    @classmethod
    def prepare_package_data(cls, package_data, is_pkginfo=True):
        """
        Return a new mapping of package_data by filtering and adjusting existing
        package data for use with `cls` class
        """
        version = get_full_version(package_data)
        package_data["version"] = version

        # the base is the source package name if present
        names = package_data["name"]
        if is_pkginfo:
            # single name/pkgname and optional pkgbase/source name defaulting to name/pkgname
            name = package_data["name"] = names[0]
            package_data["source_name"] = package_data.get("source_name") or name
        else:
            # base/source name is always present and is the name
            # multiple pkgnames
            package_data["name"] = package_data.pop("source_name")
            package_data["binary_names"] = names

        package_data = filter_unknown_attributes(cls, package_data)

        return package_data


@attr.attributes(kw_only=True)
class SourcePackage(BasePackage):
    binary_names = attr.ib(
        type=list,
        default=attr.Factory(list),
        metadata=dict(help="Package name."),
    )

    @classmethod
    def from_download_url(cls, download_url):
        """
        Return a SourcePackage built from a download URL.
        """
        file_name = shared_utils.file_name_from_url(download_url)
        pn = PackageName.from_file_name(file_name)
        return cls(
            name=pn.full_name,
            version=pn.full_version,
            arch=pn.arch or "any",
            download_url=download_url,
        )

    @classmethod
    def from_package_data(cls, package_data, download_url=None):
        """
        Return a new `SourcePackage` object built from a `package_data` mapping.
        """
        package_data = cls.prepare_package_data(package_data, is_pkginfo=False)
        package_data["download_url"] = download_url
        return cls(**package_data)


@attr.attributes(kw_only=True)
class BinaryPackage(BasePackage):
    source_name = attr.ib(
        type=str,
        default=None,
        metadata=dict(help="Source Package name"),
    )

    groups = attr.ib(type=list, default=attr.Factory(list), metadata=dict(help="groups"))
    sha256 = attr.ib(type=str, default=None, metadata=dict(help="sha256"))

    depends = attr.ib(type=list, default=attr.Factory(list), metadata=dict(help="depends"))
    makedepends = attr.ib(type=list, default=attr.Factory(list), metadata=dict(help="makedepends"))
    checkdepends = attr.ib(
        type=list, default=attr.Factory(list), metadata=dict(help="checkdepends")
    )
    optdepends = attr.ib(type=list, default=attr.Factory(list), metadata=dict(help="optdepends"))
    provides = attr.ib(type=list, default=attr.Factory(list), metadata=dict(help="provides"))

    conflicts = attr.ib(type=list, default=attr.Factory(list), metadata=dict(help="conflicts"))
    replaces = attr.ib(type=list, default=attr.Factory(list), metadata=dict(help="replaces"))

    def __attrs_post_init__(self):
        self.depends = self.split_depends(self.depends)
        self.makedepends = self.split_depends(self.makedepends)
        self.checkdepends = self.split_depends(self.checkdepends)
        self.optdepends = self.split_opt(self.optdepends)
        self.provides = dict(self.split_depends(self.provides))

    @classmethod
    def from_package_data(cls, package_data, download_url=None):
        """
        Return a BinaryPackage built from a package data mapping (from a desc or
        pkginfo file).
        """
        package_data = cls.prepare_package_data(package_data, is_pkginfo=True)
        package_data["download_url"] = download_url
        return cls(**package_data)

    @classmethod
    def from_download_url(cls, download_url):
        """
        Return a BinaryPackage built from a download URL.
        """
        file_name = shared_utils.file_name_from_url(download_url)
        pn = PackageName.from_file_name(file_name)
        return cls(
            name=pn.full_name,
            version=pn.full_version,
            arch=pn.arch or "any",
            download_url=download_url,
        )

    def get_all_dependencies(self, repo):
        """
        Yield recursively all the dependent packages of this package in a repo.
        """
        for dep_name, dep_req in self.depends:
            # TODO: use/apply dep_req to select correct version
            latest_dep_package = repo.get_binary_package(dep_name)

            if not latest_dep_package:
                raise Exception("Unable to find latest version for:", dep_name)

            if TRACE_DEP:
                print(f"Adding dep: {latest_dep_package.name}@{latest_dep_package.version}")

            # the dep needs to be fetched now
            fetch_and_update_binary_package(latest_dep_package)

            yield latest_dep_package

            for subdep in latest_dep_package.get_all_dependencies(repo):
                if TRACE_DEP:
                    print(
                        f"  Adding subdep: {subdep.name}@{subdep.version} of "
                        f"{latest_dep_package.name}@{latest_dep_package.version}"
                    )
                yield subdep

    def get_unique_dependencies(self, repo):
        """
        Return a list of unique dependent packages of this package in a repo.
        """
        unique = {}
        for dep in self.get_all_dependencies(repo):
            if dep.name not in unique:
                unique[dep.name] = dep
        return sorted(unique.values())

    @classmethod
    def split_depends(cls, deps):
        """
        Given a list of dependencies each as a string, return a list of (dep
        name, dep constraint) tuples.
        """
        r = []
        for d in deps:
            parts = re.split("([<>=]+)", d, 1)
            first = parts[0].strip()
            second = "".join(parts[1:]).strip()
            r.append((first, second))
        return r

    @classmethod
    def split_opt(cls, deps):
        """
        Given a list of optional dependencies each as a string, return a list of (dep
        name, dep constraint) tuples.
        """
        r = []
        for d in deps:
            if ":" in d:
                a, b = d.split(":", 1)
                r.append((a.strip(), b.strip()))
            else:
                r.append((d.strip(), ""))
        return r


################################################################################
# Parse package manifests
################################################################################


def parse_desc(text):
    """
    Parse a description text and return a mapping of {key: values}.
    For instance:

        %FILENAME%
        mingw-w64-x86_64-gcc-9.3.0-2-any.pkg.tar.xz

        %DEPENDS%
        mingw-w64-x86_64-crt
        mingw-w64-x86_64-headers

    will yield:
        {
        '%FILENAME%': ['mingw-w64-x86_64-gcc-9.3.0-2-any.pkg.tar.xz'],
        '%DEPENDS%': [ 'mingw-w64-x86_64-crt','mingw-w64-x86_64-headers']
        }
    """

    parsed = defaultdict(list)
    key = None
    values = []
    for line in text.splitlines():
        line = line.strip()
        if key is None:
            key = line
        elif not line:
            # an empty line means the end of values for that key and the start
            # of a new one
            parsed[key] = values
            key = None
            values = []
        else:
            values.append(line)
    if key is not None:
        parsed[key] = values

    # https://wiki.archlinux.org/index.php/User:Apg#String_List_Fields
    string_list_fields = (
        "%GROUPS%",
        "%LICENSE%",
        "%FILES%",
        "%DEPENDS%",
        "%PROVIDES%",
        "%CONFLICTS%",
        "%REPLACES%",
        "%OPTDEPENDS%",
        "%MAKEDEPENDS%",
        "%CHECKDEPENDS%",
    )

    for key, value in list(parsed.items()):
        if key in string_list_fields:
            parsed[key] = value[0]

    return normalize_package_data_keys(parsed)


# https://wiki.archlinux.org/index.php/User:Apg#String_List_Fields
STRING_LIST_FIELDS = (
    # pkgname is special: this is a list in srcinfo and a string in pkginfo
    # as one source can yield many binaries
    "pkgname",
    "group",
    "license",
    "depend",
    "depends",
    "optdepend",
    "optdepends",
    "makedepend",
    "makedepends",
    "checkdepend",
    "checkdepends",
    "conflict",
    "conflicts",
    "replaces",
    "provides",
    # .BUILDINFO
    "buildenv",
    "options",
    "installed",
    # .SRCINFO
    "source",
    "md5sums",
    "sha1sums",
    "sha224sums",
    "sha256sums",
    "sha384sums",
    "sha512sums",
    "validpgpkeys",
)


def parse_pkginfo(text, string_list_fields=STRING_LIST_FIELDS):
    """
    Parse text from a .PKGINFO found in a binary package root.
    See https://wiki.archlinux.org/index.php/User:Apg#.PKGINFO for details
    Can also parse .SRCINFO files.

    For example, a .PKGINFO:
    >>> text = '''
    ... # Generated by makepkg 5.2.2
    ... pkgname = mingw-w64-x86_64-sqlcipher
    ... pkgbase = mingw-w64-sqlcipher
    ... pkgver = 4.4.2-1
    ... license = GPL
    ... pkgdesc = SQLite extension
    ... url = https://www.zetetic.net/sqlcipher/
    ... builddate = 1607372620
    ... packager = CI (msys2-autobuild/00f7657c/406699447)
    ... size = 5267906
    ... arch = any
    ... license = BSD
    ... depend = mingw-w64-x86_64-gcc-libs
    ... depend = mingw-w64-x86_64-openssl
    ... depend = mingw-w64-x86_64-readline
    ... makedepend = mingw-w64-x86_64-tcl'''
    >>> expected = {
    ...     'name': ['mingw-w64-x86_64-sqlcipher'],
    ...     'source_name': 'mingw-w64-sqlcipher',
    ...     'version': '4.4.2-1',
    ...     'licenses': ['GPL', 'BSD'],
    ...     'desc': 'SQLite extension',
    ...     'url': 'https://www.zetetic.net/sqlcipher/',
    ...     'builddate': '1607372620',
    ...     'packager': 'CI (msys2-autobuild/00f7657c/406699447)',
    ...     'size': '5267906',
    ...     'arch': 'any',
    ...     'depends': [
    ...         'mingw-w64-x86_64-gcc-libs',
    ...         'mingw-w64-x86_64-openssl',
    ...         'mingw-w64-x86_64-readline',
    ...     ],
    ...     'makedepends': ['mingw-w64-x86_64-tcl'],
    ... }
    >>> result = parse_pkginfo(text)
    >>> assert expected == result, result


    Another example of .PKGINFO truncated for bbrevity::

    >>> text = '''# Generated by makepkg 5.2.2
    ... pkgname = mingw-w64-x86_64-gcc-libs
    ... pkgbase = mingw-w64-gcc
    ... pkgver = 10.2.0-6
    ... depend = mingw-w64-x86_64-gmp
    ... depend = mingw-w64-x86_64-mpc
    ... depend = mingw-w64-x86_64-mpfr
    ... depend = mingw-w64-x86_64-libwinpthread
    ... '''
    >>> expected = {
    ... 'name': ['mingw-w64-x86_64-gcc-libs'],
    ... 'source_name': 'mingw-w64-gcc',
    ... 'version': '10.2.0-6',
    ... 'depends': ['mingw-w64-x86_64-gmp', 'mingw-w64-x86_64-mpc', 'mingw-w64-x86_64-mpfr', 'mingw-w64-x86_64-libwinpthread'],
    ... }
    >>> result = parse_pkginfo(text)
    >>> assert expected == result, result


    For example, using a .SRCINFO text::

    >>> text = '''# Generated by makepkg 5.2.1
    ... # Mon May 25 08:54:20 UTC 2020
    ... pkgbase = mingw-w64-libarchive
    ...     pkgdesc = Multi-format archive and compression library (mingw-w64)
    ...     pkgver = 3.4.3
    ...     pkgrel = 1
    ...     url = https://www.libarchive.org/
    ...     arch = any
    ...     license = BSD
    ...     makedepends = mingw-w64-x86_64-gcc
    ...     makedepends = mingw-w64-x86_64-pkg-config
    ...     depends = mingw-w64-x86_64-gcc-libs
    ...     depends = mingw-w64-x86_64-zstd
    ...     options = !libtool
    ...     options = strip
    ...     source = libarchive-3.4.3.tar.gz::https://libarchive.org/downloads/libarchive-3.4.3.tar.gz
    ...     source = 0001-libarchive-3.3.3-bcrypt-fix.patch
    ...     sha256sums = 19556c1c67aacdff547fd719729630444dbc7161c63eca661a310676a022bb01
    ...     sha256sums = 2c318a025029998a9389eb99ab80f733c0fcf3b4888421879f2f6b4530d7f522
    ...
    ... pkgname = mingw-w64-x86_64-libarchive
    ... pkgname = mingw-w64-x86_64-libarchive2'''
    >>> expected = {'source_name': 'mingw-w64-libarchive',
    ...     'desc': 'Multi-format archive and compression library (mingw-w64)',
    ...     'version': '3.4.3', 'release': '1', 'url': 'https://www.libarchive.org/',
    ...     'arch': 'any', 'licenses': ['BSD'],
    ...     'makedepends': ['mingw-w64-x86_64-gcc', 'mingw-w64-x86_64-pkg-config'],
    ...     'depends': ['mingw-w64-x86_64-gcc-libs', 'mingw-w64-x86_64-zstd'],
    ...     'options': ['!libtool', 'strip'],
    ...     'source': [
    ...         'libarchive-3.4.3.tar.gz::https://libarchive.org/downloads/libarchive-3.4.3.tar.gz',
    ...         '0001-libarchive-3.3.3-bcrypt-fix.patch'
    ...      ],
    ...     'sha256sums': [
    ...          '19556c1c67aacdff547fd719729630444dbc7161c63eca661a310676a022bb01',
    ...         '2c318a025029998a9389eb99ab80f733c0fcf3b4888421879f2f6b4530d7f522'],
    ...     'name': ['mingw-w64-x86_64-libarchive', 'mingw-w64-x86_64-libarchive2'],
    ... }
    >>> result = parse_pkginfo(text)
    >>> assert expected == result, result


    And another .SRCINFO example with a release and epoch::

    >>> text = ''' # Generated by makepkg 5.2.1
    ... # Sat May  9 19:53:19 UTC 2020
    ... pkgbase = mingw-w64-libspiro
    ...     pkgdesc = Simplifies the drawing of beautiful curves (mingw-w64)
    ...     pkgver = 20200505
    ...     pkgrel = 1
    ...     epoch = 1
    ...     url = https://libspiro.sourceforge.io/
    ...     arch = any
    ...     license = GPL
    ...     makedepends = mingw-w64-x86_64-gcc
    ...     makedepends = mingw-w64-x86_64-pkg-config
    ...     options = staticlibs
    ...     options = strip
    ...     source = libspiro-20200505.tar.gz::https://github.com/fontforge/libspiro/archive/20200505.tar.gz
    ...     sha256sums = 00be530b5c0ea9274baadf
    ...
    ... pkgname = mingw-w64-x86_64-libspiro'''
    >>> expected = {
    ...     'source_name': 'mingw-w64-libspiro',
    ...     'desc': 'Simplifies the drawing of beautiful curves (mingw-w64)',
    ...     'version': '20200505',
    ...     'release': '1',
    ...     'epoch': '1',
    ...     'url': 'https://libspiro.sourceforge.io/',
    ...     'arch': 'any',
    ...     'licenses': ['GPL'],
    ...     'makedepends': ['mingw-w64-x86_64-gcc', 'mingw-w64-x86_64-pkg-config'],
    ...     'options': ['staticlibs', 'strip'],
    ...     'source': ['libspiro-20200505.tar.gz::https://github.com/fontforge/libspiro/archive/20200505.tar.gz'],
    ...     'sha256sums': ['00be530b5c0ea9274baadf'],
    ...     'name': ['mingw-w64-x86_64-libspiro']}
    >>> result = parse_pkginfo(text)
    >>> assert expected == result, result
    """

    lines = text.splitlines()

    pkginfo = {}
    for line in lines:
        line = line.strip()
        if not line or line.startswith("#"):
            continue

        key, _, value = line.partition("=")
        key = key.strip()
        value = value.strip()

        existing_value = pkginfo.get(key)

        if existing_value:
            if not string_list_fields or (string_list_fields and key in string_list_fields):
                # we treat this field as a list
                if isinstance(existing_value, list):
                    pkginfo[key].append(value)
                else:
                    pkginfo[key] = [existing_value, value]
                continue
            else:
                raise Exception(
                    f"Multiple values but key is not a multivalue key: "
                    f"{key} = {existing_value} and {value}",
                    text,
                )

        if key in string_list_fields:
            value = [value]
        pkginfo[key] = value

    return normalize_package_data_keys(pkginfo)


PACKAGE_DATA_KEYS_MAPPING = {
    # desc_keys_mapping
    "%NAME%": "name",
    "%ARCH%": "arch",
    "%VERSION%": "version",
    "%FILENAME%": "file_name",
    "%SHA256SUM%": "sha256",
    "%DESC%": "desc",
    "%GROUPS%": "groups",
    "%LICENSE%": "licenses",
    "%FILES%": "files",
    "%DEPENDS%": "depends",
    "%PROVIDES%": "provides",
    "%CONFLICTS%": "conflicts",
    "%REPLACES%": "replaces",
    "%OPTDEPENDS%": "optdepends",
    "%MAKEDEPENDS%": "makedepends",
    "%CHECKDEPENDS%": "checkdepends",
    # pkginfo_keys_mapping
    "pkgname": "name",
    "pkgbase": "source_name",
    "pkgver": "version",
    "pkgrel": "release",
    "pkgdesc": "desc",
    "filename": "file_name",
    "group": "groups",
    "license": "licenses",
    "depend": "depends",
    "optdepend": "optdepends",
    "makedepend": "makedepends",
    "checkdepend": "checkdepends",
    "conflict": "conflicts",
}


def normalize_package_data_keys(data, translate=PACKAGE_DATA_KEYS_MAPPING):
    """
    Given a mapping of {name:value} of package data (from a desc or .PKGINFO
    file) return a new mapping with normalized names.
    """
    new_data = {}
    for old_key, value in data.items():
        new_key = translate.get(old_key)
        if new_key:
            new_data[new_key] = value
        else:
            new_data[old_key] = value
    return new_data


################################################################################
# version comparison to make version sortable and find the latest version
################################################################################


def split_evr(version):
    """
    Return a tuple of epoch, version, release from a version string
    """
    if "~" in version:
        epoch, version = version.split("~", 1)
    else:
        epoch, version = ("0", version)

    release = None
    if "-" in version:
        version, release = version.rsplit("-", 1)
    else:
        version, release = (version, None)

    return epoch, version, release


def vercmp(version1, version2):
    """
    Compare two versions usig the same logic as cmp()
    """

    def cmp(a: int, b: int):
        return (a > b) - (a < b)

    digit, alpha, other = range(3)

    def get_char_type(c):
        assert c
        if c.isdigit():
            return digit
        elif c.isalpha():
            return alpha
        else:
            return other

    def parse(version):
        """
        Parse a version in its comparable parts
        """
        parts = []
        seps = 0
        current = ""
        for char in version:
            if get_char_type(char) == other:
                if current:
                    parts.append((seps, current))
                    current = ""
                seps += 1
            else:
                if not current:
                    current += char
                else:
                    if get_char_type(char) == get_char_type(current):
                        current += char
                    else:
                        parts.append((seps, current))
                        current = char

        parts.append((seps, current or None))

        return parts

    def rpmvercmp(version1, version2):
        """
        Compare versions using the rpm procedure.
        """
        parts1 = parse(version1)
        parts2 = parse(version2)
        aligned_parts = zip_longest(parts1, parts2, fillvalue=(None, None))
        for (s1, p1), (s2, p2) in aligned_parts:
            if s1 is not None and s2 is not None:
                ret = cmp(s1, s2)
                if ret != 0:
                    return ret

            if p1 is None and p2 is None:
                return 0

            if p1 is None:
                if get_char_type(p2) == alpha:
                    return 1
                return -1

            elif p2 is None:
                if get_char_type(p1) == alpha:
                    return -1
                return 1

            t1 = get_char_type(p1)
            t2 = get_char_type(p2)
            if t1 != t2:
                if t1 == digit:
                    return 1
                elif t2 == digit:
                    return -1
            elif t1 == digit:
                ret = cmp(int(p1), int(p2))
                if ret != 0:
                    return ret
            elif t1 == alpha:
                ret = cmp(p1, p2)
                if ret != 0:
                    return ret

        return 0

    epoch1, version1, release1 = split_evr(version1)
    epoch2, version2, release2 = split_evr(version2)

    ret = rpmvercmp(epoch1, epoch2)
    if ret == 0:
        ret = rpmvercmp(version1, version2)
        if ret == 0 and release1 is not None and release2 is not None:
            ret = rpmvercmp(release1, release2)

    return ret


# this is a key function usable in .sort() and sorted()
version_sort_key = functools.cmp_to_key(vercmp)

################################################################################
# Process and install packages in plugins
################################################################################


def has_glob(pth):
    """
    Return True if pth contains glob metacharacters (*, ?, [])
    """
    return pth != glob.escape(pth)


def install_files(extracted_dir, install_dir, real_name, copies=None):
    """
    Install libraries and licenses from the extracted_dir
    - lib dir files are installed in install_dir/lib
    - share/licenses dir files are installed in install_dir/licenses
    - share/docs dir files are installed in install_dir/docs
    """
    # map  of src to dst
    # note: the directories MUST end with a /
    copies = dict(copies)

    # also keep .BUILDINFO .PKGINFO under the licenses
    copies[".BUILDINFO"] = f"build/{real_name}/.BUILDINFO"
    copies[".PKGINFO"] = f"build/{real_name}/.PKGINFO"

    if TRACE:
        print("Installing with:", copies)

    for src_path, dst in copies.items():
        isdir = dst.endswith("/")
        src_path = os.path.join(extracted_dir, src_path)
        dst = os.path.join(install_dir, dst)

        # do we have globs? these are allowed only in the last segment
        parent = os.path.dirname(src_path)
        assert not has_glob(parent), (
            f"source: {src_path} parent dir cannot contain glob in copies to {dst}"
        )

        file_name = os.path.basename(src_path)

        if has_glob(file_name):
            if os.path.exists(parent):
                sources = fnmatch.filter(os.listdir(parent), file_name) or []
                sources = [os.path.join(parent, fn) for fn in sources]
            else:
                sources = []
        else:
            sources = [src_path]

        for src in sources:
            if os.path.exists(src):
                if TRACE:
                    print("copying:", src, dst)
                if os.path.isdir(src):
                    if TRACE_INSTALL:
                        print("Installing:", src, "to:", dst)
                    copy_tree(src, dst)
                else:
                    parent = os.path.dirname(dst)
                    os.makedirs(parent, exist_ok=True)
                    if isdir:
                        os.makedirs(dst, exist_ok=True)
                    shutil.copy2(src, dst)
                    if TRACE_INSTALL:
                        print("Installing:", src, "to:", dst)


def check_installed_files(install_dir, copies, package):
    """
    Verifies that all the `copies` operations for Package `package` took place with
    all files present in `install_dir`
    """
    missing = []
    for src, dst in copies.items():
        src_isdir = src.endswith("/")
        dst_isdir = dst.endswith("/")
        dst_loc = os.path.join(install_dir, dst)

        if dst_isdir and not src_isdir:
            # file to dir
            file_name = os.path.basename(src)
            dst_loc = os.path.join(dst_loc, file_name)
            if not os.path.exists(dst_loc):
                missing.append(dst_loc)
            continue
        if dst_isdir and src_isdir:
            # dir to dir
            if not os.path.exists(dst_loc):
                missing.append(dst_loc)
            else:
                if not os.listdir(dst_loc):
                    missing.append(dst_loc)
            continue
        if not dst_isdir:
            # file to file
            if not os.path.exists(dst_loc):
                missing.append(dst_loc)
            continue

        if src_isdir and not dst_isdir:
            # dir to file: illegal
            raise Exception(f"Illegal copy from: {src} to {dst}.")
            continue

    if missing:
        missing = "\n".join(missing)
        raise Exception(
            f"These files were not installed for {package.name}@{package.version}:\n{missing}"
        )


def fetch_and_update_source_package(binary_package, repo, indent=3, cleanup=True):
    """
    Given a binary_package and repo, fetch the sources to `SRC_CACHE_DIR`. Also
    update the repo with the newest source_package data from .SRCINFO. Return
    the location where the source_package archive was fetched and the
    SourcePackage object.
    """

    if not binary_package.source_name:
        raise Exception(f'{binary_package} is missing required "source_name"')

    source_package = repo.get_source_package(
        name=binary_package.source_name,
        version=binary_package.version,
    )

    fetched_loc = shared_utils.fetch_file(
        url=source_package.download_url,
        dir_location=SRC_CACHE_DIR,
        indent=indent,
    )

    extracted_source_dir = shared_utils.extract_in_place(fetched_loc)
    subdir = os.listdir(extracted_source_dir)[0]
    srcinfo_loc = os.path.join(extracted_source_dir, subdir, ".SRCINFO")
    source_package.update_with_info(srcinfo_loc)

    if cleanup:
        shutil.rmtree(extracted_source_dir, ignore_errors=False)
    return fetched_loc, source_package


def verify_package(package, fetched_loc):
    """
    Verify a package archive integrity if possible
    """
    if hasattr(package, "sha256"):
        shared_utils.verify(fetched_loc, package.sha256)


def fetch_and_update_binary_package(binary_package, indent=1):
    """
    Fetch, verify, extract and update a binary package and return the location
    where it was extracted
    """
    fetched_binary_loc = shared_utils.fetch_file(
        url=binary_package.download_url,
        dir_location=BIN_CACHE_DIR,
        indent=indent,
    )
    verify_package(package=binary_package, fetched_loc=fetched_binary_loc)
    extracted_dir = shared_utils.extract_in_place(fetched_binary_loc)
    pkginfo_loc = os.path.join(extracted_dir, ".PKGINFO")
    binary_package.update_with_info(pkginfo_loc)

    shared_utils.create_about_file(target_directory=BIN_CACHE_DIR, **binary_package.to_about())

    return extracted_dir


def process_package(
    binary_package,
    repo,
    copies,
    install_dir,
    indent=1,
):
    """
    Process a binary package end to end: fetch, verify, extract, update
    metadata, install, fetch and save sources, update their metadata and
    generate ABOUT files.
    """
    extracted_dir = fetch_and_update_binary_package(binary_package=binary_package, indent=indent)

    install_files(
        extracted_dir=extracted_dir,
        install_dir=install_dir,
        real_name=binary_package.real_name,
        copies=copies,
    )

    # fetch sources and update metadata
    _fetch_source_loc, source_package = fetch_and_update_source_package(
        binary_package=binary_package, repo=repo, indent=indent + 2
    )

    shared_utils.create_about_file(target_directory=SRC_CACHE_DIR, **source_package.to_about())

    return extracted_dir


def update_package(
    name,
    version=None,
    repo_name="mingw64",
    cleanup=True,
):
    """
    Fetch a `package` with `name` and optional `version` from `repo` and save
    its sources and binaries as well as its full dependency tree sources and
    binaries. Then delete the `deletes` list of paths under `install_dir`.
    Then install in `install_dir` using `copies` {from:to} copy operations.
    Finally copy sources to a source plugin and create ABOUT files for
    the included thirdparty.
    """
    # get presets
    presets = PRESETS.get(
        (
            name,
            repo_name,
        ),
        {},
    )
    version = version or presets.get("version")

    # setup base directories
    install_dir = presets["install_dir"]
    deletes = presets["deletes"]
    copies = presets["copies"]

    print("Updating package:", name, "@", version, "from repo:", repo_name)

    os.makedirs(BIN_CACHE_DIR, exist_ok=True)
    os.makedirs(SRC_CACHE_DIR, exist_ok=True)

    # cleanup deletable directories
    for deletable in deletes:
        deletable = os.path.join(install_dir, deletable)
        if os.path.exists(deletable):
            if os.path.isdir(deletable):
                shutil.rmtree(deletable, ignore_errors=False)
            else:
                os.remove(deletable)

    # populate our remote index with the list of known source and binary packages
    repo = REPOSITORIES[repo_name]
    repo.populate_package_from_index_urls()

    root_package = repo.get_binary_package(name, version)
    if not root_package:
        available = "\n".join(map(repr, repo.binaries_by_name[name]))
        raise Exception(f"Unable to find package: {name}@{version}\nbut got:\n{available}")

    if TRACE_FETCH:
        print(f"Processing package: {root_package}")
    extracted_locs = []

    extracted_loc = process_package(
        binary_package=root_package,
        repo=repo,
        copies=copies,
        install_dir=install_dir,
        indent=1,
    )

    extracted_locs.append(extracted_loc)

    dependent_packages = root_package.get_unique_dependencies(repo)
    if TRACE_FETCH:
        print(f"Fetching dependent_packages for: {root_package.name}")

    for dep_package in dependent_packages:
        if TRACE_FETCH:
            print(f"  -> Fetching dependency: {dep_package.name}")

        extracted_loc = process_package(
            binary_package=dep_package,
            repo=repo,
            copies=copies,
            install_dir=install_dir,
            indent=3,
        )
        extracted_locs.append(extracted_loc)

    # check_installed_files(install_dir, copies, root_package)
    if cleanup:
        # finally cleanup after thyself, removing extracted locations
        for loc in extracted_locs:
            shutil.rmtree(loc, False)


def main():
    update_package(name="mingw-w64-x86_64-libarchive", version="3.5.1-1", repo_name="mingw64")
    update_package(name="mingw-w64-x86_64-file", version="5.39-1", repo_name="mingw64")


PRESETS = {
    ("mingw-w64-x86_64-libarchive", "mingw64"): {
        "version": "3.5.1-1",
        "install_dir": "builtins/extractcode_libarchive-win64/src/extractcode_libarchive",
        "deletes": [
            "licenses",
            "lib",
            "doc",
            "include",
            "man",
            "build",
        ],
        "copies": {
            "mingw64/bin/*.dll": "lib/",
            "mingw64/share/licenses/": "licenses/",
            # extra uncommon licenses
            "mingw64/include/archive.h": "licenses/libarchive/libarchive.LICENSE",
            "mingw64/include/lz4frame_static.h": "licenses/lz4/lz4.LICENSE",
            "mingw64/include/mpc.h": "licenses/mpc/mpc.LICENSE",
            "mingw64/include/mpfr.h": "licenses/mpfr/mpfr.LICENSE",
            "mingw64/share/doc/mpfr/COPYING.LESSER": "licenses/mpfr/",
            "mingw64/share/doc/mpfr/AUTHORS": "licenses/mpfr/",
            "mingw64/share/doc/mpfr/COPYING": "licenses/mpfr/",
            "mingw64/share/doc/mpfr/COPYING.LESSER": "licenses/mpfr/",
            "mingw64/include/nettle/nettle-meta.h": "licenses/nettle/nettle.LICENSE",
            "mingw64/include/p11-kit-1/p11-kit/p11-kit.h": "licenses/p11-kit/p11-kit.LICENSE",
            "mingw64/include/gmp.h": "licenses/gmp/gmp.LICENSE",
        },
    },
    ("mingw-w64-x86_64-file", "mingw64"): {
        "version": "5.39-1",
        "install_dir": "builtins/typecode_libmagic-win64/src/typecode_libmagic",
        "deletes": [
            "licenses",
            "lib",
            "doc",
            "include",
            "man",
            "build",
        ],
        "copies": {
            "mingw64/bin/*.dll": "lib/",
            "mingw64/share/misc/magic.mgc": "data/magic.mgc",
            "mingw64/share/licenses/": "licenses/",
            "mingw64/include/gmp.h": "licenses/gmp/gmp.LICENSE",
            "mingw64/include/zlib.h": "licenses/zlib/zlib.LICENSE",
        },
    },
    ("mingw-w64-x86_64-universal-ctags-git", "mingw64"): {
        "version": "r7253.7492b90e-1",
        "install_dir": "binary-analysis/scancode-ctags-win64/src/scancode_ctags",
        "deletes": [
            "licenses",
            "lib",
            "doc",
            "include",
            "man",
            "build",
        ],
        "copies": {
            "mingw64/bin/ctags.exe": "bin/ctags.exe",
            "mingw64/bin/*.dll": "lib/",
            "mingw64/share/licenses/": "licenses/",
        },
    },
    ("mingw-w64-cross-binutils", "msys64"): {
        "version": "2.34-1",
        "install_dir": "binary-analysis/scancode-readelf-win64/src/scancode_readelf",
        "deletes": [
            "licenses",
            "lib",
            "doc",
            "include",
            "man",
            "build",
        ],
        "copies": {
            "mingw64/bin/readelf.*": "bin",
            "mingw64/bin/*.dll": "lib/",
            "mingw64/share/licenses/": "licenses/",
        },
    },
}

if __name__ == "__main__":
    sys.exit(main())
